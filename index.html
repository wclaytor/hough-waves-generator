<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'%3E%3Ccircle cx='96' cy='96' r='80' fill='%233b82f6'/%3E%3Cpath d='M96 40 L140 90 L115 90 L115 120 L77 120 L77 90 L52 90 Z' fill='white'/%3E%3C/svg%3E" sizes="any" type="image/svg+xml">
    <title>Hough Waves - Algorithmic Art Generator</title>
    
    <!-- Alpine.js for reactivity -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        if (typeof tailwind !== 'undefined') {
            tailwind.config = {
                darkMode: 'class'
            }
        }
    </script>
    
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    
    <style>
        [x-cloak] { display: none !important; }
        
        /* Dark mode transitions */
        * {
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
    </style>
</head>
<body>
    <div x-data="houghWaves()" x-cloak :class="darkMode ? 'dark' : ''" class="min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors duration-300">
        <div class="container mx-auto p-4 md:p-6 max-w-7xl">
            <!-- Header -->
            <header class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 md:p-6 mb-4 md:mb-6 transition-colors duration-300">
                <div class="flex items-center justify-between flex-wrap gap-4">
                    <div>
                        <h1 class="text-2xl md:text-4xl font-bold text-gray-800 dark:text-gray-100 mb-2">
                            <i class="bi bi-tsunami text-blue-500"></i>
                            Hough Waves
                        </h1>
                        <p class="text-sm md:text-base text-gray-600 dark:text-gray-300">Algorithmic Art Generator - Transform mathematics into visual art</p>
                    </div>
                    <button 
                        @click="toggleDarkMode()"
                        class="p-3 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 transition-all duration-200 border border-gray-300 dark:border-gray-600"
                        title="Toggle dark mode">
                        <i x-show="!darkMode" class="bi bi-moon text-xl"></i>
                        <i x-show="darkMode" class="bi bi-sun text-xl"></i>
                    </button>
                </div>
            </header>

            <!-- Canvas Section -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 md:p-6 mb-4 md:mb-6 transition-colors duration-300">
                <canvas x-ref="canvas" 
                        width="800" 
                        height="600" 
                        :class="darkMode ? 'bg-black' : 'bg-white'"
                        class="w-full rounded shadow-lg cursor-crosshair transition-colors duration-300"
                        style="max-height: 70vh;"></canvas>
            </div>

            <!-- Controls Section -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4 md:mb-6">
                <!-- Pattern Controls -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-4 flex items-center gap-2">
                        <i class="bi bi-bezier2 text-purple-500"></i>
                        Pattern Type
                    </h3>
                    <select x-model="pattern" @change="generate()" 
                            class="w-full px-4 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="wave">Wave</option>
                        <option value="spiral">Spiral</option>
                        <option value="circle">Circle</option>
                        <option value="grid">Grid</option>
                        <option value="random">Random</option>
                    </select>
                </div>

                <!-- Points Control -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                    <div class="mb-4 flex items-center justify-between">
                        <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 flex items-center gap-2">
                            <i class="bi bi-circle-fill text-blue-500"></i>
                            Points: <span x-text="numPoints"></span>
                        </h3>
                        <div class="flex items-center gap-1">
                            <button @click="decrementPoints()"
                                    class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 transition-all duration-200 border border-gray-300 dark:border-gray-600"
                                    title="Decrease by 1">
                                <i class="bi bi-dash text-lg"></i>
                            </button>
                            <button @click="incrementPoints()"
                                    class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 transition-all duration-200 border border-gray-300 dark:border-gray-600"
                                    title="Increase by 1">
                                <i class="bi bi-plus text-lg"></i>
                            </button>
                        </div>
                    </div>
                    <input type="range" x-model="numPoints" min="10" max="150" step="5"
                           @input="generate()" 
                           class="w-full">
                </div>

                <!-- Threshold Control -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                    <div class="mb-4 flex items-center justify-between">
                        <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 flex items-center gap-2">
                            <i class="bi bi-sliders text-green-500"></i>
                            Threshold: <span x-text="threshold"></span>
                        </h3>
                        <div class="flex items-center gap-1">
                            <button @click="decrementThreshold()"
                                    class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 transition-all duration-200 border border-gray-300 dark:border-gray-600"
                                    title="Decrease by 1">
                                <i class="bi bi-dash text-lg"></i>
                            </button>
                            <button @click="incrementThreshold()"
                                    class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 transition-all duration-200 border border-gray-300 dark:border-gray-600"
                                    title="Increase by 1">
                                <i class="bi bi-plus text-lg"></i>
                            </button>
                        </div>
                    </div>
                    <input type="range" x-model="threshold" min="5" max="50" step="1"
                           @input="generate()" 
                           class="w-full">
                </div>

                <!-- Theta Resolution Control -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                    <div class="mb-4 flex items-center justify-between">
                        <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 flex items-center gap-2">
                            <i class="bi bi-diagram-3 text-indigo-500"></i>
                            Resolution: <span x-text="thetaStep + 'Â°'"></span>
                        </h3>
                        <div class="flex items-center gap-1">
                            <button @click="decrementResolution()"
                                    class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 transition-all duration-200 border border-gray-300 dark:border-gray-600"
                                    title="Decrease by 0.1">
                                <i class="bi bi-dash text-lg"></i>
                            </button>
                            <button @click="incrementResolution()"
                                    class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 transition-all duration-200 border border-gray-300 dark:border-gray-600"
                                    title="Increase by 0.1">
                                <i class="bi bi-plus text-lg"></i>
                            </button>
                        </div>
                    </div>
                    <input type="range" x-model.number="thetaStep" min="0.5" max="5" step="0.5"
                           @input="generate()" 
                           class="w-full">
                </div>

                <!-- Opacity Control -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-4 flex items-center gap-2">
                        <i class="bi bi-droplet text-cyan-500"></i>
                        Opacity: <span x-text="(opacity * 100).toFixed(0) + '%'"></span>
                    </h3>
                    <input type="range" x-model.number="opacity" min="0.01" max="1.0" step="0.01"
                           @input="render()" 
                           class="w-full">
                </div>

                <!-- Color Mode Control -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-4 flex items-center gap-2">
                        <i class="bi bi-palette text-pink-500"></i>
                        Color Mode
                    </h3>
                    <select x-model="colorMode" @change="render()" 
                            class="w-full px-4 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="mono">Monochrome</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="gradient">Gradient</option>
                        <option value="ocean">Ocean</option>
                        <option value="fire">Fire</option>
                    </select>
                </div>

                <!-- Stats Display -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-4 flex items-center gap-2">
                        <i class="bi bi-graph-up text-orange-500"></i>
                        Statistics
                    </h3>
                    <div class="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                        <div>Lines drawn: <span class="font-semibold text-gray-800 dark:text-gray-200" x-text="lines.length"></span></div>
                        <div>Pattern: <span class="font-semibold text-gray-800 dark:text-gray-200" x-text="pattern"></span></div>
                        <div x-show="useDynamicThreshold" class="text-xs text-purple-600 dark:text-purple-400">
                            Dynamic threshold: <span x-text="Math.floor(numPoints * thresholdMultiplier)"></span>
                        </div>
                        <div class="text-xs mt-2">
                            <span x-show="useCoarseBinning" class="inline-block bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded mr-1">Coarse</span>
                            <span x-show="useDynamicThreshold" class="inline-block bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 px-2 py-0.5 rounded mr-1">Dynamic</span>
                            <span x-show="useBlurring" class="inline-block bg-pink-100 dark:bg-pink-900/30 text-pink-700 dark:text-pink-300 px-2 py-0.5 rounded mr-1">Blur</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced Optimization Options -->
            <div class="bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-950 dark:to-purple-950 rounded-lg shadow-md p-6 mb-4 md:mb-6 transition-colors duration-300">
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-4 flex items-center gap-2">
                    <i class="bi bi-gear text-indigo-500"></i>
                    Advanced Optimization Options
                </h3>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Option 1: Coarse Binning -->
                    <div class="bg-white dark:bg-gray-800 rounded-lg p-4">
                        <label class="flex items-center gap-2 mb-3 cursor-pointer">
                            <input type="checkbox" x-model="useCoarseBinning" @change="generate()" 
                                   class="w-5 h-5 text-blue-600 rounded focus:ring-2 focus:ring-blue-500">
                            <span class="font-semibold text-gray-800 dark:text-gray-100">Coarse Binning</span>
                        </label>
                        <div x-show="useCoarseBinning" class="space-y-3 text-sm">
                            <div>
                                <label class="text-gray-600 dark:text-gray-400">Theta Bin: <span x-text="thetaBinSize + 'Â°'"></span></label>
                                <input type="range" x-model.number="thetaBinSize" min="1" max="10" step="1"
                                       @input="generate()" class="w-full">
                            </div>
                            <div>
                                <label class="text-gray-600 dark:text-gray-400">Rho Bin: <span x-text="rhoBinSize + 'px'"></span></label>
                                <input type="range" x-model.number="rhoBinSize" min="2" max="20" step="1"
                                       @input="generate()" class="w-full">
                            </div>
                        </div>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">
                            Groups similar lines together. Larger bins = more votes per bin.
                        </p>
                    </div>
                    
                    <!-- Option 2: Dynamic Threshold -->
                    <div class="bg-white dark:bg-gray-800 rounded-lg p-4">
                        <label class="flex items-center gap-2 mb-3 cursor-pointer">
                            <input type="checkbox" x-model="useDynamicThreshold" @change="generate()" 
                                   class="w-5 h-5 text-purple-600 rounded focus:ring-2 focus:ring-purple-500">
                            <span class="font-semibold text-gray-800 dark:text-gray-100">Dynamic Threshold</span>
                        </label>
                        <div x-show="useDynamicThreshold" class="space-y-3 text-sm">
                            <div>
                                <label class="text-gray-600 dark:text-gray-400">Multiplier: <span x-text="(thresholdMultiplier * 100).toFixed(0) + '%'"></span></label>
                                <input type="range" x-model.number="thresholdMultiplier" min="0.05" max="0.5" step="0.05"
                                       @input="generate()" class="w-full">
                            </div>
                            <div class="text-xs text-gray-600 dark:text-gray-300">
                                Effective: <span x-text="Math.floor(numPoints * thresholdMultiplier)"></span> votes
                            </div>
                        </div>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">
                            Scales threshold based on number of points. More points = higher threshold.
                        </p>
                    </div>
                    
                    <!-- Option 3: Blurring/Averaging -->
                    <div class="bg-white dark:bg-gray-800 rounded-lg p-4">
                        <label class="flex items-center gap-2 mb-3 cursor-pointer">
                            <input type="checkbox" x-model="useBlurring" @change="generate()" 
                                   class="w-5 h-5 text-pink-600 rounded focus:ring-2 focus:ring-pink-500">
                            <span class="font-semibold text-gray-800 dark:text-gray-100">Vote Blurring</span>
                        </label>
                        <div x-show="useBlurring" class="space-y-3 text-sm">
                            <div>
                                <label class="text-gray-600 dark:text-gray-400">Blur Radius: <span x-text="blurRadius"></span></label>
                                <input type="range" x-model.number="blurRadius" min="1" max="5" step="1"
                                       @input="generate()" class="w-full">
                            </div>
                        </div>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">
                            Spreads votes to neighboring bins. Helps similar lines accumulate votes.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button @click="generate()" 
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white p-3 md:p-4 rounded-lg font-bold flex items-center justify-center gap-2 transition-colors">
                    <i class="bi bi-arrow-clockwise"></i>
                    Generate New Pattern
                </button>
                <button @click="randomize()" 
                        class="w-full bg-purple-600 hover:bg-purple-700 text-white p-3 md:p-4 rounded-lg font-bold flex items-center justify-center gap-2 transition-colors">
                    <i class="bi bi-shuffle"></i>
                    Randomize All
                </button>
                <button @click="download()" 
                        class="w-full bg-green-600 hover:bg-green-700 text-white p-3 md:p-4 rounded-lg font-bold flex items-center justify-center gap-2 transition-colors">
                    <i class="bi bi-download"></i>
                    Download PNG
                </button>
            </div>

            <!-- Info Section -->
            <div class="mt-6 bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 transition-colors duration-300">
                <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100 mb-3 flex items-center gap-2">
                    <i class="bi bi-info-circle text-blue-500"></i>
                    About Hough Waves
                </h3>
                <p class="text-gray-600 dark:text-gray-300 text-sm leading-relaxed">
                    Hough Waves use the <strong>Hough transform algorithm</strong> from computer vision to create stunning generative art. 
                    Each point generates a sinusoidal curve in parameter space (Î¸, r), voting for all possible lines through it. 
                    Lines receiving enough votes (above threshold) are drawn, creating emergent wave-like patterns. 
                    Inspired by the 2004 art project by Andreas SchjÃ¸nhaug & Kristoffer Stenersen at NTNU, Norway.
                </p>
                <div class="mt-4 flex flex-wrap gap-2">
                    <span class="px-3 py-1 bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 rounded-full text-xs font-medium">Algorithm: Hough Transform</span>
                    <span class="px-3 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-full text-xs font-medium">Alpine.js 3.x</span>
                    <span class="px-3 py-1 bg-pink-100 dark:bg-pink-900/30 text-pink-700 dark:text-pink-300 rounded-full text-xs font-medium">Generative Art</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        function houghWaves() {
            return {
                // === STATE ===
                numPoints: 50,
                threshold: 15,
                pattern: 'wave',
                opacity: 0.05,
                colorMode: 'mono',
                lines: [],
                darkMode: false,
                canvas: null,
                ctx: null,
                thetaStep: 1, // Resolution of theta sampling (degrees)
                
                // === OPTIMIZATION OPTIONS ===
                useCoarseBinning: false,
                thetaBinSize: 1,  // Degrees per bin (when coarse binning enabled)
                rhoBinSize: 2,    // Pixels per bin (when coarse binning enabled)
                useDynamicThreshold: false,
                thresholdMultiplier: 0.2,  // Percentage of points
                useBlurring: false,
                blurRadius: 1,    // Number of neighboring bins to blur into

                // === INITIALIZATION ===
                init() {
                    this.canvas = this.$refs.canvas;
                    this.ctx = this.canvas.getContext('2d');
                    
                    // Load dark mode preference
                    const savedDarkMode = localStorage.getItem('hough-waves-darkMode');
                    this.darkMode = savedDarkMode === 'true';
                    this.updateDarkMode();
                    
                    // Generate initial pattern
                    this.generate();
                },

                // === DARK MODE ===
                toggleDarkMode() {
                    this.darkMode = !this.darkMode;
                    this.updateDarkMode();
                    localStorage.setItem('hough-waves-darkMode', this.darkMode.toString());
                    // Re-render with new theme colors
                    this.render();
                },

                updateDarkMode() {
                    if (this.darkMode) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                },

                // === POINTS CONTROL ===
                incrementPoints() {
                    if (this.numPoints < 150) {
                        this.numPoints++;
                        this.generate();
                    }
                },

                decrementPoints() {
                    if (this.numPoints > 10) {
                        this.numPoints--;
                        this.generate();
                    }
                },

                // === THRESHOLD CONTROL ===
                incrementThreshold() {
                    if (this.threshold < 50) {
                        this.threshold++;
                        this.generate();
                    }
                },

                decrementThreshold() {
                    if (this.threshold > 5) {
                        this.threshold--;
                        this.generate();
                    }
                },

                // === RESOLUTION CONTROL ===
                incrementResolution() {
                    if (this.thetaStep < 5) {
                        this.thetaStep = Math.round((this.thetaStep + 0.1) * 10) / 10;
                        this.generate();
                    }
                },

                decrementResolution() {
                    if (this.thetaStep > 0.5) {
                        this.thetaStep = Math.round((this.thetaStep - 0.1) * 10) / 10;
                        this.generate();
                    }
                },

                // === MAIN GENERATION ===
                generate() {
                    this.clear();
                    const points = this.createPoints();
                    this.lines = this.computeHoughTransform(points);
                    this.render();
                },

                // === POINT GENERATION ===
                createPoints() {
                    const points = [];
                    const n = parseInt(this.numPoints);
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    
                    const patterns = {
                        wave: (i) => ({
                            x: (i/n) * w,
                            y: h/2 + Math.sin(i/n * Math.PI * 4) * 150
                        }),
                        spiral: (i) => {
                            const angle = (i/n) * Math.PI * 6;
                            const radius = (i/n) * Math.min(w, h) * 0.4;
                            return {
                                x: w/2 + Math.cos(angle) * radius,
                                y: h/2 + Math.sin(angle) * radius
                            };
                        },
                        circle: (i) => {
                            const angle = (i/n) * Math.PI * 2;
                            const radius = Math.min(w, h) * 0.3;
                            return {
                                x: w/2 + Math.cos(angle) * radius,
                                y: h/2 + Math.sin(angle) * radius
                            };
                        },
                        grid: (i) => {
                            const cols = Math.ceil(Math.sqrt(n));
                            return {
                                x: ((i % cols) / cols) * w,
                                y: (Math.floor(i / cols) / cols) * h
                            };
                        },
                        random: (i) => ({
                            x: Math.random() * w,
                            y: Math.random() * h
                        })
                    };
                    
                    for (let i = 0; i < n; i++) {
                        const point = patterns[this.pattern](i);
                        // Add slight noise for organic feel (except for random pattern)
                        if (this.pattern !== 'random') {
                            point.x += (Math.random() - 0.5) * 20;
                            point.y += (Math.random() - 0.5) * 20;
                        }
                        points.push(point);
                    }
                    
                    return points;
                },

                // === HOUGH TRANSFORM ===
                computeHoughTransform(points) {
                    const accumulator = new Map();
                    const lines = [];
                    const w = this.canvas.width;
                    const h = this.canvas.height;
                    const maxRho = Math.sqrt(w * w + h * h);
                    
                    // Determine binning sizes (Option 1: Coarse Binning)
                    const thetaBinSize = this.useCoarseBinning ? this.thetaBinSize : 1;
                    const rhoBinSize = this.useCoarseBinning ? this.rhoBinSize : 2;
                    
                    // Helper function to cast a vote (with optional blurring)
                    const castVote = (thetaKey, rhoKey, weight = 1) => {
                        const key = `${thetaKey},${rhoKey}`;
                        const count = (accumulator.get(key) || 0) + weight;
                        accumulator.set(key, count);
                    };
                    
                    // For each point, vote for all possible lines through it
                    points.forEach(point => {
                        // Vary theta from -90 to +90 degrees
                        for (let thetaDeg = -90; thetaDeg <= 90; thetaDeg += this.thetaStep) {
                            const theta = thetaDeg * Math.PI / 180;
                            
                            // Calculate r = x*cos(Î¸) + y*sin(Î¸)
                            const rho = point.x * Math.cos(theta) + point.y * Math.sin(theta);
                            
                            // Quantize theta and rho for binning
                            const thetaKey = Math.round(thetaDeg / thetaBinSize) * thetaBinSize;
                            const rhoKey = Math.round(rho / rhoBinSize) * rhoBinSize;
                            
                            // Cast primary vote
                            castVote(thetaKey, rhoKey, 1.0);
                            
                            // Option 3: Vote Blurring - spread vote to neighboring bins
                            if (this.useBlurring) {
                                const radius = this.blurRadius;
                                for (let dt = -radius; dt <= radius; dt++) {
                                    for (let dr = -radius; dr <= radius; dr++) {
                                        if (dt === 0 && dr === 0) continue; // Skip center (already voted)
                                        
                                        const neighborTheta = thetaKey + (dt * thetaBinSize);
                                        const neighborRho = rhoKey + (dr * rhoBinSize);
                                        
                                        // Gaussian-like weight: closer neighbors get more weight
                                        const distance = Math.sqrt(dt * dt + dr * dr);
                                        const weight = Math.exp(-distance * distance / (2 * radius * radius)) * 0.5;
                                        
                                        castVote(neighborTheta, neighborRho, weight);
                                    }
                                }
                            }
                        }
                    });
                    
                    // Option 2: Dynamic Threshold - scale based on number of points
                    const threshold = this.useDynamicThreshold 
                        ? Math.max(5, Math.floor(points.length * this.thresholdMultiplier))
                        : parseInt(this.threshold);
                    
                    // Find lines that exceed threshold
                    accumulator.forEach((votes, key) => {
                        if (votes >= threshold) {
                            const [thetaKey, rhoKey] = key.split(',').map(Number);
                            const theta = thetaKey * Math.PI / 180;
                            const rho = rhoKey;
                            lines.push({ theta, rho, strength: votes });
                        }
                    });
                    
                    // Sort by strength for better rendering
                    lines.sort((a, b) => a.strength - b.strength);
                    
                    return lines;
                },

                // === RENDERING ===
                render() {
                    this.clear();
                    this.lines.forEach((line, idx) => {
                        this.drawLine(
                            line.theta, 
                            line.rho, 
                            this.getColor(idx, this.lines.length),
                            line.strength
                        );
                    });
                },

                drawLine(theta, rho, color, strength) {
                    const cos = Math.cos(theta);
                    const sin = Math.sin(theta);
                    
                    let x0 = cos * rho;
                    let y0 = sin * rho;
                    
                    let x1 = x0 - sin * 1000;
                    let y1 = y0 + cos * 1000;
                    let x2 = x0 + sin * 1000;
                    let y2 = y0 - cos * 1000;
                    
                    this.ctx.strokeStyle = color;
                    this.ctx.globalAlpha = parseFloat(this.opacity) * Math.min(1, strength / 10);
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                    this.ctx.globalAlpha = 1;
                },

                // === COLOR MODES ===
                getColor(index, total) {
                    const modes = {
                        mono: () => this.darkMode ? '#ffffff' : '#000000',
                        rainbow: () => `hsl(${(index/total) * 360}, 70%, ${this.darkMode ? 60 : 40}%)`,
                        gradient: () => {
                            const t = index / total;
                            if (this.darkMode) {
                                return `rgb(${255*t}, ${255*(1-t)}, 255)`;
                            } else {
                                return `rgb(${200*t}, ${200*(1-t)}, 200)`;
                            }
                        },
                        ocean: () => `hsl(${180 + (index/total) * 60}, 70%, ${this.darkMode ? 60 : 40}%)`,
                        fire: () => `hsl(${(index/total) * 60}, 80%, ${this.darkMode ? 60 : 40}%)`
                    };
                    
                    return modes[this.colorMode]();
                },

                // === UTILITIES ===
                clear() {
                    // Use light background in light mode, dark in dark mode
                    this.ctx.fillStyle = this.darkMode ? '#000000' : '#ffffff';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                },

                download() {
                    const link = document.createElement('a');
                    link.download = `hough-waves-${Date.now()}.png`;
                    link.href = this.canvas.toDataURL();
                    link.click();
                },

                randomize() {
                    this.numPoints = 20 + Math.floor(Math.random() * 100);
                    this.threshold = 10 + Math.floor(Math.random() * 30);
                    this.opacity = 0.02 + Math.random() * 0.3; // Range from 2% to 32%
                    this.thetaStep = 0.5 + Math.random() * 2.5;
                    this.pattern = ['wave', 'spiral', 'circle', 'grid', 'random'][Math.floor(Math.random() * 5)];
                    this.colorMode = ['mono', 'rainbow', 'gradient', 'ocean', 'fire'][Math.floor(Math.random() * 5)];
                    this.generate();
                }
            }
        }
    </script>

    <!-- PWA Functionality -->
    <script>
        // Listen for PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA Install prompt available!');
            // Optionally, you can store the event and show a custom install button
            // e.preventDefault();
            // window.deferredPrompt = e;
        });

        const iconSize = 192;

        // Dynamically created manifest
        const manifest = {
            name: 'Hough Waves - Algorithmic Art',
            short_name: 'Hough Waves',
            display: 'standalone',
            theme_color: '#3b82f6',
            background_color: '#f9fafb',
            start_url: window.location.href,
            // PNG icon will be converted from SVG
        };

        // Convert the SVG favicon to PNG for platforms that don't support SVG
        // (Safari and Firefox on Android)
        (async function() {
            const svgIconLink = document.querySelector('link[rel="icon"]');

            // Convert from SVG string to PNG data URL
            const pngDataUrl = await svgToPng(svgIconLink.href, iconSize);

            // Set the icon meta tags to the new PNG
            setIcon("link[rel='icon']", pngDataUrl, iconSize);
            setIcon("link[rel='apple-touch-icon']", pngDataUrl);

            // Dynamically create manifest
            manifest.icons = [{
                src: pngDataUrl,
                sizes: `${iconSize}x${iconSize}`,
                type: 'image/png'
            }];

            // Set the manifest meta tag data url
            setManifest(manifest);

            // Generate and set the iOS startup image
            const startupImageDataUrl = await createStartupImage(
                svgIconLink.href,
                manifest.background_color
            );
            const startupLink = document.createElement('link');
            startupLink.rel = 'apple-touch-startup-image';
            startupLink.href = startupImageDataUrl;
            document.head.appendChild(startupLink);
        })();

        function setManifest(manifest) {
            const link = document.createElement('link');
            link.rel = 'manifest';
            const b64manifest = btoa(JSON.stringify(manifest));
            link.href = "data:application/json;base64," + b64manifest;
            document.head.appendChild(link);
        }

        function setIcon(query, iconurl, size) {
            const iconLink = document.querySelector(query);
            iconLink.href = iconurl;
            iconLink.type = 'image/png';
            if (size) {
                iconLink.setAttribute('sizes', `${size}x${size}`);
            }
        }

        function svgToPng(svgDataUrl, size) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, size, size);
                    const pngDataUrl = canvas.toDataURL('image/png');
                    resolve(pngDataUrl);
                };
                img.onerror = reject;
                img.src = svgDataUrl;
            });
        }

        // Safari needs a startup image
        function createStartupImage(svgDataUrl, bgColor) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const canvas = document.createElement('canvas');
                    canvas.width = window.screen.width * dpr;
                    canvas.height = window.screen.height * dpr;
                    const ctx = canvas.getContext('2d');

                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const iconDisplaySize = canvas.width * 0.25;
                    const x = (canvas.width - iconDisplaySize) / 2;
                    const y = (canvas.height - iconDisplaySize) / 2;
                    ctx.drawImage(img, x, y, iconDisplaySize, iconDisplaySize);

                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = reject;
                img.src = svgDataUrl;
            });
        }
    </script>
</body>
</html>
